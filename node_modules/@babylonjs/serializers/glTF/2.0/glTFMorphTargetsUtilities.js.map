{"version":3,"file":"glTFMorphTargetsUtilities.js","sourceRoot":"","sources":["../../../../../dev/serializers/src/glTF/2.0/glTFMorphTargetsUtilities.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IBufferView, IAccessor } from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType } from \"babylonjs-gltf2interface\";\r\nimport type { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\n\r\nimport { NormalizeTangent } from \"./glTFUtilities\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Interface to store morph target information.\r\n * @internal\r\n */\r\nexport interface IMorphTargetData {\r\n    attributes: Record<string, number>;\r\n    influence: number;\r\n    name: string;\r\n}\r\n\r\nexport function BuildMorphTargetBuffers(\r\n    morphTarget: MorphTarget,\r\n    mesh: Mesh,\r\n    bufferManager: BufferManager,\r\n    bufferViews: IBufferView[],\r\n    accessors: IAccessor[],\r\n    convertToRightHanded: boolean\r\n): IMorphTargetData {\r\n    const result: IMorphTargetData = {\r\n        attributes: {},\r\n        influence: morphTarget.influence,\r\n        name: morphTarget.name,\r\n    };\r\n\r\n    const flipX = convertToRightHanded ? -1 : 1;\r\n    const floatSize = 4;\r\n    const difference = Vector3.Zero();\r\n    let vertexStart = 0;\r\n    let vertexCount = 0;\r\n\r\n    if (morphTarget.hasPositions) {\r\n        const morphPositions = morphTarget.getPositions()!;\r\n        const originalPositions = mesh.getVerticesData(VertexBuffer.PositionKind, undefined, undefined, true);\r\n\r\n        if (originalPositions) {\r\n            const positionData = new Float32Array(originalPositions.length);\r\n            const min = [Infinity, Infinity, Infinity];\r\n            const max = [-Infinity, -Infinity, -Infinity];\r\n            vertexCount = originalPositions.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalPosition = Vector3.FromArray(originalPositions, i * 3);\r\n                const morphPosition = Vector3.FromArray(morphPositions, i * 3);\r\n                morphPosition.subtractToRef(originalPosition, difference);\r\n                difference.x *= flipX;\r\n\r\n                min[0] = Math.min(min[0], difference.x);\r\n                max[0] = Math.max(max[0], difference.x);\r\n\r\n                min[1] = Math.min(min[1], difference.y);\r\n                max[1] = Math.max(max[1], difference.y);\r\n\r\n                min[2] = Math.min(min[2], difference.z);\r\n                max[2] = Math.max(max[2], difference.z);\r\n\r\n                positionData[i * 3] = difference.x;\r\n                positionData[i * 3 + 1] = difference.y;\r\n                positionData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphPositions.length / 3, 0, { min, max });\r\n            accessors.push(accessor);\r\n            result.attributes[\"POSITION\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasNormals) {\r\n        const morphNormals = morphTarget.getNormals()!;\r\n        const originalNormals = mesh.getVerticesData(VertexBuffer.NormalKind, undefined, undefined, true);\r\n\r\n        if (originalNormals) {\r\n            const normalData = new Float32Array(originalNormals.length);\r\n            vertexCount = originalNormals.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalNormal = Vector3.FromArray(originalNormals, i * 3).normalize();\r\n                const morphNormal = Vector3.FromArray(morphNormals, i * 3).normalize();\r\n                morphNormal.subtractToRef(originalNormal, difference);\r\n\r\n                normalData[i * 3] = difference.x * flipX;\r\n                normalData[i * 3 + 1] = difference.y;\r\n                normalData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphNormals.length / 3, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"NORMAL\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasTangents) {\r\n        const morphTangents = morphTarget.getTangents()!;\r\n        const originalTangents = mesh.getVerticesData(VertexBuffer.TangentKind, undefined, undefined, true);\r\n\r\n        if (originalTangents) {\r\n            vertexCount = originalTangents.length / 4;\r\n            const tangentData = new Float32Array(vertexCount * 3);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                // Only read the x, y, z components and ignore w\r\n                const originalTangent = Vector3.FromArray(originalTangents, i * 4);\r\n                NormalizeTangent(originalTangent);\r\n\r\n                // Morph target tangents omit the w component so it won't be present in the data\r\n                const morphTangent = Vector3.FromArray(morphTangents, i * 3);\r\n                NormalizeTangent(morphTangent);\r\n\r\n                morphTangent.subtractToRef(originalTangent, difference);\r\n                tangentData[i * 3] = difference.x * flipX;\r\n                tangentData[i * 3 + 1] = difference.y;\r\n                tangentData[i * 3 + 2] = difference.z;\r\n            }\r\n            const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"TANGENT\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasColors) {\r\n        const morphColors = morphTarget.getColors()!;\r\n        const originalColors = mesh.getVerticesData(VertexBuffer.ColorKind, undefined, undefined, true);\r\n\r\n        const buffer = mesh.getVertexBuffer(VertexBuffer.ColorKind, true);\r\n\r\n        if (originalColors && buffer) {\r\n            const componentSize = buffer.getSize();\r\n\r\n            vertexCount = originalColors.length / componentSize;\r\n            const colorData = new Float32Array(vertexCount * componentSize);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                if (componentSize === 3) {\r\n                    const originalColor = Vector3.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector3.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference);\r\n                    colorData[i * 3] = difference.x;\r\n                    colorData[i * 3 + 1] = difference.y;\r\n                    colorData[i * 3 + 2] = difference.z;\r\n                } else if (componentSize === 4) {\r\n                    const difference4 = new Vector4();\r\n                    const originalColor = Vector4.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector4.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference4);\r\n                    colorData[i * 4] = difference4.x;\r\n                    colorData[i * 4 + 1] = difference4.y;\r\n                    colorData[i * 4 + 2] = difference4.z;\r\n                    colorData[i * 4 + 3] = difference4.w;\r\n                } else {\r\n                    Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);\r\n                }\r\n            }\r\n            const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);\r\n            const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? AccessorType.VEC3 : AccessorType.VEC4, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"COLOR_0\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n"]}