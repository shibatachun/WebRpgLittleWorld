{"version":3,"file":"glTFMaterialExporter.js","sourceRoot":"","sources":["../../../../../dev/serializers/src/glTF/2.0/glTFMaterialExporter.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable babylonjs/available */\r\n\r\nimport type { ITextureInfo, IMaterial, IMaterialPbrMetallicRoughness, IMaterialOcclusionTextureInfo, ISampler, IImage } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { GLTFExporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { SpecularPowerToRoughness } from \"core/Helpers/materialConversionHelper\";\r\n\r\nconst epsilon = 1e-6;\r\nconst dielectricSpecular = new Color3(0.04, 0.04, 0.04);\r\nconst maxSpecularPower = 1024;\r\nconst white = Color3.White();\r\nconst black = Color3.Black();\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @internal\r\n */\r\ninterface IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    specularColor: Color3;\r\n    glossiness: number;\r\n}\r\n\r\ninterface IPBRMetallicRoughness {\r\n    baseColor: Color3;\r\n    metallic: Nullable<number>;\r\n    roughness: Nullable<number>;\r\n    metallicRoughnessTextureData?: Nullable<ArrayBuffer>;\r\n    baseColorTextureData?: Nullable<ArrayBuffer>;\r\n}\r\n\r\nfunction GetFileExtensionFromMimeType(mimeType: ImageMimeType): string {\r\n    switch (mimeType) {\r\n        case ImageMimeType.JPEG:\r\n            return \".jpg\";\r\n        case ImageMimeType.PNG:\r\n            return \".png\";\r\n        case ImageMimeType.WEBP:\r\n            return \".webp\";\r\n        case ImageMimeType.AVIF:\r\n            return \".avif\";\r\n    }\r\n}\r\n\r\n/**\r\n * Computes the metallic factor from specular glossiness values.\r\n * @param diffuse diffused value\r\n * @param specular specular value\r\n * @param oneMinusSpecularStrength one minus the specular strength\r\n * @returns metallic value\r\n * @internal\r\n */\r\nexport function _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n    if (specular < dielectricSpecular.r) {\r\n        dielectricSpecular;\r\n        return 0;\r\n    }\r\n\r\n    const a = dielectricSpecular.r;\r\n    const b = (diffuse * oneMinusSpecularStrength) / (1.0 - dielectricSpecular.r) + specular - 2.0 * dielectricSpecular.r;\r\n    const c = dielectricSpecular.r - specular;\r\n    const d = b * b - 4.0 * a * c;\r\n    return Scalar.Clamp((-b + Math.sqrt(d)) / (2.0 * a), 0, 1);\r\n}\r\n\r\n/**\r\n * Computes the metallic/roughness factors from a Standard Material.\r\n * @internal\r\n */\r\nexport function _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n    const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\r\n    const opacity = babylonStandardMaterial.alpha;\r\n    const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, maxSpecularPower);\r\n\r\n    const roughness = SpecularPowerToRoughness(specularPower);\r\n\r\n    const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n        baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n        metallicFactor: 0,\r\n        roughnessFactor: roughness,\r\n    };\r\n\r\n    return glTFPbrMetallicRoughness;\r\n}\r\n\r\n/**\r\n * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n * @param glTFMaterial glTF material\r\n * @param babylonMaterial Babylon material\r\n */\r\nfunction SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff?: number }): void {\r\n    if (babylonMaterial.needAlphaBlending()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n    } else if (babylonMaterial.needAlphaTesting()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n        glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n    }\r\n}\r\n\r\nfunction CreateWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n    const data = new Uint8Array(width * height * 4);\r\n\r\n    for (let i = 0; i < data.length; i = i + 4) {\r\n        data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n    }\r\n\r\n    const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n    return rawTexture;\r\n}\r\n\r\nfunction ConvertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n    if (pixels instanceof Uint8Array) {\r\n        const length = pixels.length;\r\n        const buffer = new Float32Array(pixels.length);\r\n        for (let i = 0; i < length; ++i) {\r\n            buffer[i] = pixels[i] / 255;\r\n        }\r\n        return buffer;\r\n    } else if (pixels instanceof Float32Array) {\r\n        return pixels;\r\n    } else {\r\n        throw new Error(\"Unsupported pixel format!\");\r\n    }\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.\r\n * @internal\r\n */\r\nexport class GLTFMaterialExporter {\r\n    // Mapping to store textures\r\n    private _textureMap = new Map<BaseTexture, ITextureInfo>();\r\n\r\n    // Mapping of internal textures to images to avoid exporting duplicate images\r\n    private _internalTextureToImage: { [uniqueId: number]: { [mimeType: string]: Promise<number> } } = {};\r\n\r\n    constructor(private readonly _exporter: GLTFExporter) {}\r\n\r\n    public getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        return babylonTexture ? (this._textureMap.get(babylonTexture) ?? null) : null;\r\n    }\r\n\r\n    public async exportStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasUVs: boolean): Promise<number> {\r\n        const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const material: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            material.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const diffuseTexture = babylonStandardMaterial.diffuseTexture;\r\n            if (diffuseTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(diffuseTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            pbrMetallicRoughness.baseColorTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.normalTexture = textureInfo;\r\n                            if (bumpTexture.level !== 1) {\r\n                                material.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonStandardMaterial.emissiveTexture;\r\n            if (emissiveTexture) {\r\n                material.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.emissiveTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonStandardMaterial.ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: textureInfo.index,\r\n                            };\r\n                            material.occlusionTexture = occlusionTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                material.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(black, epsilon)) {\r\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\r\n        SetAlphaMode(material, babylonStandardMaterial);\r\n\r\n        await this._finishMaterialAsync(material, babylonStandardMaterial, mimeType);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(material);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _finishMaterialAsync(glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType): Promise<void> {\r\n        const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n\r\n        const promises: Array<Promise<Nullable<ITextureInfo>>> = [];\r\n\r\n        for (const texture of textures) {\r\n            promises.push(this.exportTextureAsync(texture, mimeType));\r\n        }\r\n\r\n        await Promise.all(promises);\r\n\r\n        await this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n    }\r\n\r\n    private async _getImageDataAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<ArrayBuffer> {\r\n        const textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n        const hostingScene = this._exporter._babylonScene;\r\n        const engine = hostingScene.getEngine();\r\n\r\n        // Create a temporary texture with the texture buffer data\r\n        const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n        engine.isWebGPU ? await import(\"core/ShadersWGSL/pass.fragment\") : await import(\"core/Shaders/pass.fragment\");\r\n        await TextureTools.ApplyPostProcess(\"pass\", tempTexture, hostingScene, textureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n\r\n        const data = await engine._readTexturePixels(tempTexture, width, height);\r\n\r\n        return (await DumpTools.DumpDataAsync(width, height, data, mimeType, undefined, true, true)) as ArrayBuffer;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises = new Array<Promise<void>>();\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return Promise.reject(\"diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = black;\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!sRGBBaseColorPixel.equalsWithEpsilon(white, epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!metallicRoughnessPixel.equalsWithEpsilon(white, epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.metallicRoughnessTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.baseColorTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: IPBRSpecularGlossiness): IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - dielectricSpecular.r) / Math.max(1 - metallic));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(dielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises: Promise<void>[] = [];\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial._albedoColor,\r\n            metallic: babylonPBRMaterial._metallic,\r\n            roughness: babylonPBRMaterial._roughness,\r\n        };\r\n\r\n        if (hasUVs) {\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(babylonPBRMaterial._albedoTexture!, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const metallicTexture = babylonPBRMaterial._metallicTexture;\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(metallicTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (promises.length > 0) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n            await Promise.all(promises);\r\n        }\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    private _getTextureSampler(texture: Nullable<BaseTexture>): ISampler {\r\n        const sampler: ISampler = {};\r\n        if (!texture || !(texture instanceof Texture)) {\r\n            return sampler;\r\n        }\r\n\r\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\r\n        if (wrapS !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapS = wrapS;\r\n        }\r\n\r\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\r\n        if (wrapT !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapT = wrapT;\r\n        }\r\n\r\n        switch (texture.samplingMode) {\r\n            case Texture.LINEAR_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        pbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const specGloss: IPBRSpecularGlossiness = {\r\n            diffuseColor: babylonPBRMaterial._albedoColor,\r\n            specularColor: babylonPBRMaterial._reflectivityColor,\r\n            glossiness: babylonPBRMaterial._microSurface,\r\n        };\r\n\r\n        const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n        const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n        const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n        if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n            return Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n        }\r\n\r\n        if ((albedoTexture || reflectivityTexture) && hasUVs) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n\r\n            const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\r\n            const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType);\r\n\r\n            const textures = this._exporter._textures;\r\n\r\n            if (metallicRoughnessFactors.baseColorTextureData) {\r\n                const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);\r\n                pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\r\n            }\r\n\r\n            if (metallicRoughnessFactors.metallicRoughnessTextureData) {\r\n                const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);\r\n                pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\r\n            }\r\n\r\n            return metallicRoughnessFactors;\r\n        } else {\r\n            return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n        }\r\n    }\r\n\r\n    public async exportPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, mimeType: ImageMimeType, hasUVs: boolean): Promise<number> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n        }\r\n\r\n        const metallicRoughness = useMetallicRoughness\r\n            ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasUVs)\r\n            : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasUVs);\r\n\r\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasUVs);\r\n        await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial, mimeType);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(glTFMaterial);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _setMetallicRoughnessPbrMaterialAsync(\r\n        metallicRoughness: IPBRMetallicRoughness,\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        mimeType: ImageMimeType,\r\n        hasUVs: boolean\r\n    ): Promise<void> {\r\n        SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n\r\n        if (!metallicRoughness.baseColor.equalsWithEpsilon(white, epsilon) || !Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, epsilon)) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n        }\r\n\r\n        if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n        }\r\n        if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n        }\r\n\r\n        if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n            if (!babylonPBRMaterial._twoSidedLighting) {\r\n                Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const bumpTexture = babylonPBRMaterial._bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonPBRMaterial._ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                                extensions: glTFTexture.extensions,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            const ambientTextureStrength = babylonPBRMaterial._ambientTextureStrength;\r\n                            if (ambientTextureStrength) {\r\n                                occlusionTexture.strength = ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonPBRMaterial._emissiveTexture;\r\n            if (emissiveTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        const emissiveColor = babylonPBRMaterial._emissiveColor;\r\n        if (!emissiveColor.equalsWithEpsilon(black, epsilon)) {\r\n            glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    private _getPixelsFromTexture(babylonTexture: BaseTexture): Promise<Nullable<Uint8Array | Float32Array>> {\r\n        const pixels =\r\n            babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n                ? (babylonTexture.readPixels() as Promise<Uint8Array>)\r\n                : (babylonTexture.readPixels() as Promise<Float32Array>);\r\n        return pixels;\r\n    }\r\n\r\n    public async exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return extensionPromise.then((texture) => {\r\n            if (!texture) {\r\n                return this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    private async _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        let textureInfo = this._textureMap.get(babylonTexture);\r\n        if (!textureInfo) {\r\n            const pixels = await this._getPixelsFromTexture(babylonTexture);\r\n            if (!pixels) {\r\n                return null;\r\n            }\r\n\r\n            const samplerIndex = this._exportTextureSampler(babylonTexture);\r\n\r\n            // Preserve texture mime type if defined\r\n            const textureMimeType = (babylonTexture as Texture).mimeType;\r\n            if (textureMimeType) {\r\n                switch (textureMimeType) {\r\n                    case \"image/jpeg\":\r\n                    case \"image/png\":\r\n                    case \"image/webp\":\r\n                        mimeType = textureMimeType as ImageMimeType;\r\n                        break;\r\n                    default:\r\n                        Tools.Warn(`Unsupported media type: ${textureMimeType}`);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            const internalTextureToImage = this._internalTextureToImage;\r\n            const internalTextureUniqueId = babylonTexture.getInternalTexture()!.uniqueId;\r\n            internalTextureToImage[internalTextureUniqueId] ||= {};\r\n            let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][mimeType];\r\n            if (imageIndexPromise === undefined) {\r\n                const size = babylonTexture.getSize();\r\n                imageIndexPromise = (async () => {\r\n                    const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);\r\n                    return this._exportImage(babylonTexture.name, mimeType, data);\r\n                })();\r\n                internalTextureToImage[internalTextureUniqueId][mimeType] = imageIndexPromise;\r\n            }\r\n\r\n            textureInfo = this._exportTextureInfo(await imageIndexPromise, samplerIndex, babylonTexture.coordinatesIndex);\r\n            this._textureMap.set(babylonTexture, textureInfo);\r\n            this._exporter._extensionsPostExportTextures(\"exporter\", textureInfo, babylonTexture);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportImage(name: string, mimeType: ImageMimeType, data: ArrayBuffer): number {\r\n        const images = this._exporter._images;\r\n\r\n        let image: IImage;\r\n        if (this._exporter._shouldUseGlb) {\r\n            image = {\r\n                name: name,\r\n                mimeType: mimeType,\r\n                bufferView: undefined, // Will be updated later by BufferManager\r\n            };\r\n            const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));\r\n            this._exporter._bufferManager.setBufferView(image, bufferView);\r\n        } else {\r\n            // Build a unique URI\r\n            const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\r\n            const extension = GetFileExtensionFromMimeType(mimeType);\r\n            let fileName = baseName + extension;\r\n            if (images.some((image) => image.uri === fileName)) {\r\n                fileName = `${baseName}_${Tools.RandomId()}${extension}`;\r\n            }\r\n\r\n            image = {\r\n                name: name,\r\n                uri: fileName,\r\n            };\r\n            this._exporter._imageData[fileName] = { data: data, mimeType: mimeType }; // Save image data to be written to file later\r\n        }\r\n\r\n        images.push(image);\r\n\r\n        return images.length - 1;\r\n    }\r\n\r\n    private _exportTextureInfo(imageIndex: number, samplerIndex: number, coordinatesIndex?: number): ITextureInfo {\r\n        const textures = this._exporter._textures;\r\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\r\n        if (textureIndex === -1) {\r\n            textureIndex = textures.length;\r\n            textures.push({\r\n                source: imageIndex,\r\n                sampler: samplerIndex,\r\n            });\r\n        }\r\n\r\n        const textureInfo: ITextureInfo = { index: textureIndex };\r\n        if (coordinatesIndex) {\r\n            textureInfo.texCoord = coordinatesIndex;\r\n        }\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportTextureSampler(texture: Nullable<BaseTexture>): number {\r\n        const sampler = this._getTextureSampler(texture);\r\n\r\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n        const samplers = this._exporter._samplers;\r\n        const samplerIndex = samplers.findIndex(\r\n            (s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT\r\n        );\r\n        if (samplerIndex !== -1) {\r\n            return samplerIndex;\r\n        }\r\n\r\n        samplers.push(sampler);\r\n        return samplers.length - 1;\r\n    }\r\n}\r\n"]}