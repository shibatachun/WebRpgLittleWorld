{"version":3,"file":"KHR_lights_punctual.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ConvertToRightHandedPosition, OmitDefaultValues, CollapseParentNode, IsParentAddedByImporter } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\nconst DEFAULTS: Omit<IKHRLightsPunctual_Light, \"type\"> = {\r\n    name: \"\",\r\n    color: [1, 1, 1],\r\n    intensity: 1,\r\n    range: Number.MAX_VALUE,\r\n};\r\nconst SPOTDEFAULTS: NonNullable<IKHRLightsPunctual_Light[\"spot\"]> = {\r\n    innerConeAngle: 0,\r\n    outerConeAngle: Math.PI / 4.0,\r\n};\r\nconst LIGHTDIRECTION = Vector3.Backward();\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter!._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of babylon node to glTF node index\r\n     * @param convertToRightHanded Flag to convert the values to right-handed\r\n     * @returns nullable INode promise\r\n     */\r\n    public postExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return new Promise((resolve) => {\r\n            if (!(babylonNode instanceof ShadowLight)) {\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            const lightType =\r\n                babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                    ? KHRLightsPunctual_LightType.POINT\r\n                    : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                      ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                      : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                        ? KHRLightsPunctual_LightType.SPOT\r\n                        : null;\r\n            if (!lightType) {\r\n                Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME}`);\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {\r\n                Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME} specification!`);\r\n            }\r\n\r\n            // Set the node's translation and rotation here, since lights are not handled in exportNodeAsync\r\n            if (!babylonNode.position.equalsToFloats(0, 0, 0)) {\r\n                const translation = TmpVectors.Vector3[0].copyFrom(babylonNode.position);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(translation);\r\n                }\r\n                node.translation = translation.asArray();\r\n            }\r\n\r\n            // Babylon lights have \"constant\" rotation and variable direction, while\r\n            // glTF lights have variable rotation and constant direction. Therefore,\r\n            // compute a quaternion that aligns the Babylon light's direction with glTF's constant one.\r\n            if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                const direction = babylonNode.direction.normalizeToRef(TmpVectors.Vector3[0]);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(direction);\r\n                }\r\n                const angle = Math.acos(Vector3.Dot(LIGHTDIRECTION, direction));\r\n                const axis = Vector3.Cross(LIGHTDIRECTION, direction);\r\n                const lightRotationQuaternion = Quaternion.RotationAxisToRef(axis, angle, TmpVectors.Quaternion[0]);\r\n                if (!Quaternion.IsIdentity(lightRotationQuaternion)) {\r\n                    node.rotation = lightRotationQuaternion.asArray();\r\n                }\r\n            }\r\n\r\n            const light: IKHRLightsPunctual_Light = {\r\n                type: lightType,\r\n                name: babylonNode.name,\r\n                color: babylonNode.diffuse.asArray(),\r\n                intensity: babylonNode.intensity,\r\n                range: babylonNode.range,\r\n            };\r\n            OmitDefaultValues(light, DEFAULTS);\r\n\r\n            // Separately handle the required 'spot' field for spot lights\r\n            if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                const babylonSpotLight = babylonNode as SpotLight;\r\n                light.spot = {\r\n                    innerConeAngle: babylonSpotLight.innerAngle / 2.0,\r\n                    outerConeAngle: babylonSpotLight.angle / 2.0,\r\n                };\r\n                OmitDefaultValues(light.spot, SPOTDEFAULTS);\r\n            }\r\n\r\n            this._lights ||= {\r\n                lights: [],\r\n            };\r\n            this._lights.lights.push(light);\r\n\r\n            const lightReference: IKHRLightsPunctual_LightReference = {\r\n                light: this._lights.lights.length - 1,\r\n            };\r\n\r\n            // Assign the light to its parent node, if possible, to condense the glTF\r\n            // Why and when: the glTF loader generates a new parent TransformNode for each light node, which we should undo on export\r\n            const parentBabylonNode = babylonNode.parent;\r\n\r\n            if (parentBabylonNode && IsParentAddedByImporter(babylonNode, parentBabylonNode)) {\r\n                const parentNodeIndex = nodeMap.get(parentBabylonNode);\r\n                if (parentNodeIndex) {\r\n                    // Combine the light's transformation with the parent's\r\n                    const parentNode = this._exporter._nodes[parentNodeIndex];\r\n                    CollapseParentNode(node, parentNode);\r\n                    parentNode.extensions ||= {};\r\n                    parentNode.extensions[NAME] = lightReference;\r\n\r\n                    // Do not export the original node\r\n                    resolve(null);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = lightReference;\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n"]}