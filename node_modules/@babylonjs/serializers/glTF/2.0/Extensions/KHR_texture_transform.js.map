{"version":3,"file":"KHR_texture_transform.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ITextureInfo, IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\n/**\r\n * Computes the adjusted offset for a rotation centered about the origin.\r\n * @internal\r\n */\r\nfunction AdjustOffsetForRotationCenter(babylonTexture: Texture): [number, number] {\r\n    const { uOffset, vOffset, uRotationCenter, vRotationCenter, uScale, vScale, wAng } = babylonTexture;\r\n    const cosAngle = Math.cos(wAng);\r\n    const sinAngle = Math.sin(wAng);\r\n    const scaledURotationCenter = uRotationCenter * uScale;\r\n    const scaledVRotationCenter = vRotationCenter * vScale;\r\n    const deltaU = scaledURotationCenter * (1 - cosAngle) + scaledVRotationCenter * sinAngle;\r\n    const deltaV = scaledVRotationCenter * (1 - cosAngle) - scaledURotationCenter * sinAngle;\r\n    return [uOffset + deltaU, vOffset + deltaV];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        const scene = babylonTexture.getScene();\r\n        if (!scene) {\r\n            Tools.Warn(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n        }\r\n\r\n        /*\r\n         * The KHR_texture_transform schema only supports w rotation around the origin.\r\n         * See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates.\r\n         */\r\n        if (babylonTexture.uAng !== 0 || babylonTexture.vAng !== 0) {\r\n            Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation in the u or v axis is not supported in glTF.`);\r\n            // Usually, we'd always early return here if the texture uses an unsupported combination of transform properties,\r\n            // but we're making an exception here to maintain backwards compatibility.\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const textureTransform: IKHRTextureTransform = {};\r\n        let transformIsRequired = false;\r\n\r\n        if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n            textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n            textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.wAng !== 0) {\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                // See https://github.com/mrdoob/three.js/issues/15831 for more details.\r\n                if (babylonTexture.homogeneousRotationInUVTransform && babylonTexture.uScale !== babylonTexture.vScale) {\r\n                    Tools.Warn(\r\n                        `${context}: Texture ${babylonTexture.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${NAME}.`\r\n                    );\r\n                    return;\r\n                }\r\n                Tools.Warn(`${context}: Texture ${babylonTexture.name} with non-origin rotation center will be exported using an adjusted offset with ${NAME}.`);\r\n                textureTransform.offset = AdjustOffsetForRotationCenter(babylonTexture);\r\n            }\r\n            textureTransform.rotation = -babylonTexture.wAng;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.coordinatesIndex !== 0) {\r\n            textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (!transformIsRequired) {\r\n            return;\r\n        }\r\n\r\n        this._wasUsed = true;\r\n        if (!textureInfo.extensions) {\r\n            textureInfo.extensions = {};\r\n        }\r\n        textureInfo.extensions[NAME] = textureTransform;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_texture_transform());\r\n"]}