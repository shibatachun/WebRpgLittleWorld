{"version":3,"file":"glTFSerializer.js","sourceRoot":"","sources":["../../../../../dev/serializers/src/glTF/2.0/glTFSerializer.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAgE9C;;GAEG;AACH,MAAM,OAAO,WAAW;IACpB;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAY,EAAE,QAAgB,EAAE,OAAwB;QAClF,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,4BAA4B,EAAE,CAAC;YACpD,MAAM,KAAK,CAAC,cAAc,EAAE,CAAC;QACjC,CAAC;QAED,MAAM,QAAQ,GAAG,IAAI,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAClD,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC;QACjF,QAAQ,CAAC,OAAO,EAAE,CAAC;QAEnB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAY,EAAE,QAAgB,EAAE,OAAwB;QACjF,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,4BAA4B,EAAE,CAAC;YACpD,MAAM,KAAK,CAAC,cAAc,EAAE,CAAC;QACjC,CAAC;QAED,MAAM,QAAQ,GAAG,IAAI,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAClD,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC;QAChF,QAAQ,CAAC,OAAO,EAAE,CAAC;QAEnB,OAAO,IAAI,CAAC;IAChB,CAAC;CACJ","sourcesContent":["import type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { GLTFData } from \"./glTFData\";\r\nimport { GLTFExporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Mesh compression methods.\r\n */\r\nexport type MeshCompressionMethod = \"None\" | \"Draco\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function which indicates whether an animation on the scene should be exported or not\r\n     * @param animation source animation\r\n     * @returns boolean, which indicates whether the animation should be exported (true) or not (false)\r\n     */\r\n    shouldExportAnimation?(animation: Animation): boolean;\r\n\r\n    /**\r\n     * Function used to extract the part of node's metadata that will be exported into glTF node extras\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store to glTF node extras\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves. Defaults to 1 / 60.\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready. Defaults to false.\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if unused vertex uv attributes should be included in export. Defaults to false.\r\n     */\r\n    exportUnusedUVs?: boolean;\r\n\r\n    /**\r\n     * Remove no-op root nodes when possible. Defaults to true.\r\n     */\r\n    removeNoopRootNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export. Defaults to false.\r\n     * @deprecated Please use removeNoopRootNodes instead\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates what compression method to apply to mesh data.\r\n     */\r\n    meshCompressionMethod?: MeshCompressionMethod;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the scene to .gltf file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .gltf file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLTFAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLTFAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Exports the scene to .glb file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .glb file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLBAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLBAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n}\r\n"]}